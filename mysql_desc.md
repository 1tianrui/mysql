####总结系列一  :   Mysql 数据库
[优秀博客](http://www.jb51.net/article/38929.htm)
[mysql体系结构](http://www.php100.com/html/webkaifa/database/Mysql/2012/0208/9790.html)
>存储引擎
事务隔离级别
锁
MVVC
主从库
存储结构
索引类型
查询优化
cp30 And dbcp
Spring  推荐dpcp
Hibernate 推荐 cp30

**事务隔离级别**
>与编写程序中的锁对应，因为系统 for  数据处理，所以只能通过锁来保护程序片段来保护数据的并发安全，而数据库可以直接保护数据
我们把事务想象成一个个线程，这些线程共享数据，每个数据都在线程内有缓存,数据变动会在线程退出时刷到磁盘--->数据可见性问题
>RU    
>RC
>RR
>串行化

脏读: 某个事务读取了另一个事务写入的数据，但是另一个事务回滚了

幻读:一个事务中两次查询结果不一致

**MVCC**(多版本控制协议)
>1.读写分离（COW类似，因为读体量很大）
>2.history

**索引**
B+树
聚簇索引 非聚簇索引
[理解聚簇索引和非聚簇索引](http://www.jb51.net/article/29693.htm)

___聚簇索引___
与主键是相同的.为了得到好的性能需要了解聚簇索引。
1.如果在表中定义了主键，innodb用主键作为聚簇索引
2.如果没有主键，innodb选择第一个只有非空行的唯一索引作为主键，并且innodb将他用作局聚簇索引
3.否则innodb自己生成一个包含行ID的复合列作为聚簇索引

___除了聚簇索引都被称为二级索引___
二级索引包含主键，因此主键不宜过长

主键，唯一索引，普通索引，全文索引
join操作是只要char 和archer声明的长度一致是可以通过索引的
前缀索引 :char   varcahr binary varbinary
不要用or   用  in


**锁**
共享锁，排他锁(行级锁 innob)
● Record Lock：锁定单条记录
● Gap Lock：锁定一个范围的记录、但不包括记录本身
● Next-Key Lock：锁定一个范围的记录、并且包
含记录本身、这是默认的锁类型
更新操作执行流程:
   1.当前读
   2.返回并且加锁
   3.更新行
   4.返回成功

InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕

innob  count()函数会扫表
mysiam 直接读内存

死锁回滚策略：
权重较小的回滚



**查询优化**
>1.考虑加索引， 索引在表连接时尤为重要,可以通过explain语句查询结果进行优化
>2.调整缓存使用的内存大小，搞笑使用Innob缓冲池，查询缓存
>3.避免使用事务，注意锁的使用
>4.or尽量用in代替
>5.性能监控和分析恐惧  mysqltunner mysqlreport
>6.尽量减少扫描行数
>(总的来说就是数据缓存，锁，数据库连接，索引，sql涉及数据量,sql优化,性能监控, 日志占用磁盘io , 主从同步占用资源 )
